"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const node_crypto = require("node:crypto");
const shared = require("./shared-CVkLQiOG.cjs");
function textToBuffer(text) {
  return Buffer.from(typeof text === "string" ? text : new Uint8Array(text));
}
const createHmac = (data, key) => {
  return node_crypto.createHmac("sha256", textToBuffer(key)).update(textToBuffer(data)).digest();
};
function hashToken(token) {
  return Buffer.from(shared.hashToken(token, createHmac));
}
function isValid(value, token, options) {
  return shared.isValid(value, token, validate, options);
}
function sign(data, key, authDate, options) {
  return shared.sign(data, key, authDate, signData, options);
}
function signData(data, key, options) {
  return shared.signData(data, key, createHmac, options);
}
function validate(value, token, options) {
  return shared.validate(value, token, signData, options);
}
exports.ERR_AUTH_DATE_INVALID = shared.ERR_AUTH_DATE_INVALID;
exports.ERR_EXPIRED = shared.ERR_EXPIRED;
exports.ERR_HASH_INVALID = shared.ERR_HASH_INVALID;
exports.ERR_PARSE = shared.d$1;
exports.ERR_SIGN_INVALID = shared.ERR_SIGN_INVALID;
exports.ERR_UNEXPECTED_VALUE = shared.D;
exports.TypedError = shared.d;
exports.initDataToSearchParams = shared.initDataToSearchParams;
exports.isErrorOfType = shared.F;
exports.isValid3rd = shared.isValid3rd;
exports.parse = shared.parse;
exports.validate3rd = shared.validate3rd;
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
//# sourceMappingURL=node.cjs.map
