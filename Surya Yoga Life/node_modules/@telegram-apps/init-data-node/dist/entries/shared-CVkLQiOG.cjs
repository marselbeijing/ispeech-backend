"use strict";
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function removeUndefined(object) {
  const result = {};
  for (const key in object) {
    const v = object[key];
    if (v !== void 0) {
      result[key] = v;
    }
  }
  return result;
}
function serializeUser(user) {
  return user ? JSON.stringify({
    added_to_attachment_menu: user.addedToAttachmentMenu,
    allows_write_to_pm: user.allowsWriteToPm,
    first_name: user.firstName,
    id: user.id,
    is_bot: user.isBot,
    is_premium: user.isPremium,
    language_code: user.languageCode,
    last_name: user.lastName,
    photo_url: user.photoUrl,
    username: user.username
  }) : void 0;
}
function initDataToSearchParams({
  chat,
  receiver,
  user,
  ...data
}) {
  var _a;
  return new URLSearchParams(
    removeUndefined({
      auth_date: data.authDate ? (+data.authDate / 1e3 | 0).toString() : void 0,
      can_send_after: (_a = data.canSendAfter) == null ? void 0 : _a.toString(),
      chat: chat ? JSON.stringify({
        id: chat.id,
        type: chat.type,
        title: chat.title,
        photo_url: chat.type,
        username: chat.username
      }) : void 0,
      chat_instance: data.chatInstance,
      chat_type: data.chatType || void 0,
      query_id: data.queryId,
      receiver: serializeUser(receiver),
      start_param: data.startParam || void 0,
      user: serializeUser(user),
      signature: data.signature,
      hash: data.hash
    })
  );
}
function sign(data, key, authDate, signData2, options) {
  const sp = initDataToSearchParams({
    ...data,
    authDate
  });
  const pairs = [...sp.entries()].map(([name, value]) => `${name}=${value}`).sort();
  function processSign2(s) {
    sp.append("hash", s);
    return sp.toString();
  }
  const sign2 = signData2(pairs.join("\n"), key, options);
  return typeof sign2 === "string" ? processSign2(sign2) : sign2.then(processSign2);
}
function arrayBufferToHex(buffer) {
  return new Uint8Array(buffer).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error("Hex string must have an even number of characters");
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i2 = 0; i2 < hexString.length; i2 += 2) {
    uint8Array[i2 / 2] = parseInt(hexString.substring(i2, i2 + 2), 16);
  }
  return buffer;
}
function signData(data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : key : hashToken(key, createHmac);
  if (keyHmac instanceof Promise) {
    return keyHmac.then((v) => createHmac(data, v)).then(arrayBufferToHex);
  }
  const hmac = createHmac(data, keyHmac);
  return hmac instanceof Promise ? hmac.then(arrayBufferToHex) : arrayBufferToHex(hmac);
}
let d$1 = class d extends Error {
  constructor(e, t, n) {
    super(
      typeof t == "object" ? t.message : t || e,
      {
        cause: typeof t == "object" ? t.cause : n
      }
    ), this.type = e, this.name = "TypedError", Object.setPrototypeOf(this, d.prototype);
  }
};
function F(r, e) {
  return r instanceof d$1 && r.type === e;
}
const ERR_AUTH_DATE_INVALID = "ERR_AUTH_DATE_INVALID";
const ERR_HASH_INVALID = "ERR_HASH_INVALID";
const ERR_SIGNATURE_MISSING = "ERR_SIGNATURE_MISSING";
const ERR_EXPIRED = "ERR_EXPIRED";
const ERR_SIGN_INVALID = "ERR_SIGN_INVALID";
function processSign(actual, expected) {
  if (actual !== expected) {
    throw new d$1(ERR_SIGN_INVALID, "Sign is invalid");
  }
  return;
}
function validate(value, token, signData2, options = {}) {
  let authDate;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    throw new d$1(ERR_HASH_INVALID, "Hash is invalid");
  }
  if (!authDate) {
    throw new d$1(ERR_AUTH_DATE_INVALID, "Auth date is invalid");
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    if (+authDate + expiresIn * 1e3 < Date.now()) {
      throw new d$1(ERR_EXPIRED, "Init data is expired");
    }
  }
  pairs.sort();
  const sign2 = signData2(pairs.join("\n"), token, options);
  return typeof sign2 === "string" ? processSign(sign2, hash) : sign2.then((v) => processSign(v, hash));
}
function isValid(value, token, validate2, options) {
  try {
    const maybePromise = validate2(value, token, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
function processResult(verified) {
  if (!verified) {
    throw new d$1(ERR_SIGN_INVALID, "Sign is invalid");
  }
  return;
}
function validate3rd$1(value, botId, verify, options = {}) {
  let authDate;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    throw new d$1(ERR_SIGNATURE_MISSING, "Signature is missing");
  }
  if (!authDate) {
    throw new d$1(ERR_AUTH_DATE_INVALID, "Auth date is invalid");
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    if (+authDate + expiresIn * 1e3 < Date.now()) {
      throw new d$1(ERR_EXPIRED, "Init data is expired");
    }
  }
  const verified = verify(
    `${botId}:WebAppData
${pairs.sort().join("\n")}`,
    options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
    signature
  );
  return typeof verified === "boolean" ? processResult(verified) : verified.then(processResult);
}
function isValid3rd$1(value, botId, validate2, options) {
  try {
    const maybePromise = validate2(value, botId, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
class u extends Error {
  constructor(e, r, n) {
    super(
      typeof r == "object" ? r.message : r || e,
      {
        cause: typeof r == "object" ? r.cause : n
      }
    ), this.type = e, this.name = "TypedError", Object.setPrototypeOf(this, u.prototype);
  }
}
function h(t) {
  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);
}
const w = "ERR_INVALID_VALUE", D = "ERR_UNEXPECTED_VALUE", W = "ERR_UNEXPECTED_TYPE", d2 = "ERR_PARSE";
function A(t, e) {
  const r = {};
  for (const n in t) {
    const o = t[n];
    if (!o)
      continue;
    let a, c;
    typeof o == "function" ? (a = n, c = o) : [a, c] = o;
    try {
      const s = c(e(a));
      s !== void 0 && (r[n] = s);
    } catch (s) {
      throw new u(
        d2,
        `Parser for "${n}" property failed${a === n ? "" : `. Source field: "${a}"`}`,
        s
      );
    }
  }
  return r;
}
function P(t) {
  let e = t;
  if (typeof e == "string")
    try {
      e = JSON.parse(e);
    } catch (r) {
      throw new u(w, { cause: r });
    }
  if (typeof e != "object" || !e || Array.isArray(e))
    throw new u(D);
  return e;
}
function i(t, e) {
  return (r) => {
    const n = (o) => {
      if (!(r && o === void 0))
        try {
          return e(o);
        } catch (a) {
          throw new u(d2, {
            message: `"${t}" transformer failed to parse the value`,
            cause: a
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      n,
      {
        isValid(o) {
          try {
            return n(o), true;
          } catch {
            return false;
          }
        }
      }
    );
  };
}
function m(t, e) {
  return i(e || "object", (r) => {
    const n = P(r);
    return A(t, (o) => n[o]);
  });
}
function p(t) {
  throw new u(W, `Unexpected value received: ${JSON.stringify(t)}`);
}
const E = i("boolean", (t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return true;
  if (e === "0" || e === "false")
    return false;
  p(t);
}), f = i("string", (t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  p(t);
}), g = i("number", (t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  p(t);
}), U = i("date", (t) => t instanceof Date ? t : new Date(g()(t) * 1e3));
function R(t, e) {
  return i(e, (r) => {
    typeof r != "string" && !(r instanceof URLSearchParams) && p(r);
    const n = typeof r == "string" ? new URLSearchParams(r) : r;
    return A(t, (o) => {
      const a = n.get(o);
      return a === null ? void 0 : a;
    });
  });
}
function l(t) {
  for (const e in t)
    t[e] = [h(e), t[e]];
  return t;
}
const N = (t) => {
  const e = g(), r = g(true), n = f(), o = f(true), a = E(true), c = m(l({
    addedToAttachmentMenu: a,
    allowsWriteToPm: a,
    firstName: n,
    id: e,
    isBot: a,
    isPremium: a,
    languageCode: o,
    lastName: o,
    photoUrl: o,
    username: o
  }), "User")(true);
  return R(
    l({
      authDate: U(),
      canSendAfter: r,
      chat: m(
        l({
          id: e,
          type: n,
          title: n,
          photoUrl: o,
          username: o
        }),
        "Chat"
      )(true),
      chatInstance: o,
      chatType: o,
      hash: n,
      queryId: o,
      receiver: c,
      startParam: o,
      signature: n,
      user: c
    }),
    "initData"
  )(t);
};
function parse(value) {
  return N()(value);
}
const verify3rd = async (data, key, signature) => {
  return crypto.subtle.verify(
    "Ed25519",
    await crypto.subtle.importKey("raw", Buffer.from(key, "hex"), "Ed25519", false, ["verify"]),
    Buffer.from(signature, "base64"),
    Buffer.from(data)
  );
};
async function validate3rd(value, botId, options) {
  return validate3rd$1(value, botId, verify3rd, options);
}
function isValid3rd(value, botId, options) {
  return isValid3rd$1(value, botId, validate3rd, options);
}
exports.D = D;
exports.ERR_AUTH_DATE_INVALID = ERR_AUTH_DATE_INVALID;
exports.ERR_EXPIRED = ERR_EXPIRED;
exports.ERR_HASH_INVALID = ERR_HASH_INVALID;
exports.ERR_SIGN_INVALID = ERR_SIGN_INVALID;
exports.F = F;
exports.d = d$1;
exports.d$1 = d2;
exports.hashToken = hashToken;
exports.initDataToSearchParams = initDataToSearchParams;
exports.isValid = isValid;
exports.isValid3rd = isValid3rd;
exports.parse = parse;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
exports.validate3rd = validate3rd;
//# sourceMappingURL=shared-CVkLQiOG.cjs.map
