{"version":3,"file":"shared-BvCEfSRU.js","sources":["../../src/hashToken.ts","../../src/initDataToSearchParams.ts","../../src/sign.ts","../../src/converters/arrayBufferToHex.ts","../../src/converters/hexToArrayBuffer.ts","../../src/signData.ts","../../../toolkit/dist/index.js","../../src/errors.ts","../../src/validate.ts","../../src/isValid.ts","../../src/validate3rd.ts","../../src/isValid3rd.ts","../../../transformers/dist/index.js","../../src/parse.ts","../../src/entries/shared.ts"],"sourcesContent":["import type { CreateHmacFn, Text } from './types.js';\n\nexport function hashToken<H extends CreateHmacFn<any>>(token: Text, createHmac: H): ReturnType<H> {\n  return createHmac(token, 'WebAppData') as ReturnType<H>;\n}\n","import type { InitData, User } from '@telegram-apps/types';\n\n/**\n * Removes undefined properties from the object.\n * @param object - object to remove properties from.\n */\nfunction removeUndefined(object: Record<string, string | undefined>): Record<string, string> {\n  const result: Record<string, string> = {};\n  for (const key in object) {\n    const v = object[key];\n    if (v !== undefined) {\n      result[key] = v;\n    }\n  }\n  return result;\n}\n\n/**\n * Serializes user information.\n * @param user - user information.\n */\nfunction serializeUser(user: User | undefined): string | undefined {\n  return user\n    ? JSON.stringify({\n      added_to_attachment_menu: user.addedToAttachmentMenu,\n      allows_write_to_pm: user.allowsWriteToPm,\n      first_name: user.firstName,\n      id: user.id,\n      is_bot: user.isBot,\n      is_premium: user.isPremium,\n      language_code: user.languageCode,\n      last_name: user.lastName,\n      photo_url: user.photoUrl,\n      username: user.username,\n    })\n    : undefined;\n}\n\nexport function initDataToSearchParams({\n  chat,\n  receiver,\n  user,\n  ...data\n}: Partial<InitData>): URLSearchParams {\n  return new URLSearchParams(\n    removeUndefined({\n      auth_date: data.authDate\n        ? ((+data.authDate / 1000) | 0).toString()\n        : undefined,\n      can_send_after: data.canSendAfter?.toString(),\n      chat: chat\n        ? JSON.stringify({\n          id: chat.id,\n          type: chat.type,\n          title: chat.title,\n          photo_url: chat.type,\n          username: chat.username,\n        })\n        : undefined,\n      chat_instance: data.chatInstance,\n      chat_type: data.chatType || undefined,\n      query_id: data.queryId,\n      receiver: serializeUser(receiver),\n      start_param: data.startParam || undefined,\n      user: serializeUser(user),\n      signature: data.signature,\n      hash: data.hash,\n    }),\n  );\n}","import { initDataToSearchParams } from './initDataToSearchParams.js';\n\nimport type { SharedOptions, SignData, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\n\nexport type SignOptions = SharedOptions;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn,\n  options?: SignOptions,\n): string;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataAsyncFn,\n  options?: SignOptions,\n): Promise<string>;\n\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options?: SignOptions,\n): string | Promise<string> {\n  // Create search parameters, which will be signed further.\n  const sp = initDataToSearchParams({\n    ...data,\n    authDate,\n  });\n\n  // Convert search params to pairs and sort the final array.\n  const pairs = [...sp.entries()]\n    .map(([name, value]) => `${name}=${value}`)\n    .sort();\n\n  // Compute sign, append it to the params and return.\n  function processSign(s: string): string {\n    sp.append('hash', s);\n    return sp.toString();\n  }\n\n  const sign = signData(pairs.join('\\n'), key, options);\n  return typeof sign === 'string' ? processSign(sign) : sign.then(processSign);\n}\n","/**\n * Converts array buffer to hex.\n * @param buffer - buffer to convert\n */\nexport function arrayBufferToHex(buffer: ArrayBuffer): string {\n  return new Uint8Array(buffer).reduce((acc, byte) => {\n    // Convert byte to hex and pad with zero if needed (e.g., \"0a\" instead of \"a\")\n    return acc + byte.toString(16).padStart(2, '0');\n  }, '');\n}\n","/**\n * Converts a hex string to ArrayBuffer.\n * @param hexString - value to convert.\n */\nexport function hexToArrayBuffer(hexString: string): ArrayBuffer {\n  if (hexString.length % 2 !== 0) {\n    throw new Error('Hex string must have an even number of characters');\n  }\n\n  const buffer = new ArrayBuffer(hexString.length / 2);\n  const uint8Array = new Uint8Array(buffer);\n  for (let i = 0; i < hexString.length; i += 2) {\n    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n\n  return buffer;\n}","import { hashToken } from './hashToken.js';\nimport { arrayBufferToHex } from './converters/arrayBufferToHex.js';\nimport { hexToArrayBuffer } from './converters/hexToArrayBuffer.js';\nimport type { CreateHmacFn, SharedOptions, Text } from './types.js';\n\nexport type SignDataOptions = SharedOptions;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<false>,\n  options?: SignDataOptions,\n): string;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<true>,\n  options?: SignDataOptions,\n): Promise<string>;\n\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<boolean>,\n  options: SignDataOptions = {},\n): string | Promise<string> {\n  const keyHmac = options.tokenHashed\n    ? typeof key === 'string'\n      // If a hashed token was passed, we assume that it is a HEX string. Not to mess with\n      // the createHmac function, we should convert this HEX string to ArrayBuffer. Otherwise,\n      // incorrect behavior will be met.\n      ? hexToArrayBuffer(key)\n      : key\n    : hashToken(key, createHmac);\n\n  if (keyHmac instanceof Promise) {\n    return keyHmac.then(v => createHmac(data, v)).then(arrayBufferToHex);\n  }\n\n  const hmac = createHmac(data, keyHmac);\n  return hmac instanceof Promise ? hmac.then(arrayBufferToHex) : arrayBufferToHex(hmac);\n}\n","var k = Object.defineProperty;\nvar I = (r, e, t) => e in r ? k(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar E = (r, e, t) => I(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass d extends Error {\n  constructor(e, t, n) {\n    super(\n      typeof t == \"object\" ? t.message : t || e,\n      {\n        cause: typeof t == \"object\" ? t.cause : n\n      }\n    ), this.type = e, this.name = \"TypedError\", Object.setPrototypeOf(this, d.prototype);\n  }\n}\nfunction x(r, e, t) {\n  return r.addEventListener(e, t), () => r.removeEventListener(e, t);\n}\nfunction _(...r) {\n  const e = r.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\nfunction F(r, e) {\n  return r instanceof d && r.type === e;\n}\nfunction m(r) {\n  return (e) => F(e, r);\n}\nconst R = \"ERR_ABORTED\", $ = \"ERR_CANCELED\", S = \"ERR_TIMED_OUT\";\nfunction T(r) {\n  return new d(R, { cause: r });\n}\nconst U = m(S), V = m(R), B = m($);\nfunction C(r, e) {\n  return r.reject = e.reject, r;\n}\nclass i extends Promise {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u, c;\n    super((a, h) => {\n      s || (s = {});\n      const { abortSignal: l } = s;\n      if (l && l.aborted)\n        return h(T(l.reason));\n      const [y, A] = _(), b = (f) => (...L) => (A(), f(...L)), w = new AbortController(), { signal: D } = w;\n      c = b((f) => {\n        w.abort(f), h(f);\n      }), u = b(a), l && y(\n        x(l, \"abort\", () => {\n          c(T(l.reason));\n        })\n      );\n      const { timeout: g } = s;\n      if (g) {\n        const f = setTimeout(() => {\n          c(new d(S, `Timeout reached: ${g}ms`));\n        }, g);\n        y(() => {\n          clearTimeout(f);\n        });\n      }\n      o && o(u, c, D);\n    });\n    /**\n     * Rejects the promise.\n     */\n    E(this, \"reject\");\n    this.reject = c;\n  }\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new i((o, s, u) => {\n      try {\n        const c = t(u);\n        return c instanceof Promise ? c.then(o, s) : o(c);\n      } catch (c) {\n        s(c);\n      }\n    }, n);\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new i((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new i((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * Cancels the promise execution.\n   */\n  cancel() {\n    this.reject(new d($));\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return C(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return C(super.then(t, n), this);\n  }\n}\nfunction v(r, e) {\n  return r.resolve = e.resolve, r;\n}\nclass p extends i {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u;\n    super((c, a, h) => {\n      u = c, o && o(c, a, h);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    E(this, \"resolve\");\n    this.resolve = u;\n  }\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new p(\n      (o, s, u) => i.withFn(t, { abortSignal: u }).then(o, s),\n      n\n    );\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new p((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new p((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return v(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return v(super.then(t, n), this);\n  }\n}\nfunction Z(r, e) {\n  return new i((t) => {\n    setTimeout(t, r);\n  }, { abortSignal: e });\n}\nfunction j(r) {\n  return `tapps/${r}`;\n}\nfunction J(r, e) {\n  sessionStorage.setItem(j(r), JSON.stringify(e));\n}\nfunction K(r) {\n  const e = sessionStorage.getItem(j(r));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction M(r) {\n  return r.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction z(r) {\n  return r.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction G(r) {\n  return r.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(r, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: o = !0\n  } = e;\n  function s(u, ...c) {\n    if (!o || typeof o == \"function\" && !o())\n      return;\n    const a = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n    console[u](\n      `%c${Intl.DateTimeFormat(\"en-GB\", {\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        fractionalSecondDigits: 3,\n        timeZone: \"UTC\"\n      }).format(/* @__PURE__ */ new Date())}%c / %c${r}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n      ...c\n    );\n  }\n  return [\n    function(...c) {\n      s(\"log\", ...c);\n    },\n    function(...c) {\n      s(\"error\", ...c);\n    }\n  ];\n}\nfunction H(r, e) {\n  document.documentElement.style.setProperty(r, e);\n}\nfunction P(r) {\n  document.documentElement.style.removeProperty(r);\n}\nexport {\n  i as CancelablePromise,\n  R as ERR_ABORTED,\n  $ as ERR_CANCELED,\n  S as ERR_TIMED_OUT,\n  p as EnhancedPromise,\n  d as TypedError,\n  x as addEventListener,\n  M as camelToKebab,\n  z as camelToSnake,\n  T as createAbortError,\n  _ as createCbCollector,\n  q as createLogger,\n  m as createTypedErrorPredicate,\n  P as deleteCssVar,\n  K as getStorageValue,\n  V as isAbortError,\n  B as isCanceledError,\n  F as isErrorOfType,\n  U as isTimeoutError,\n  H as setCssVar,\n  J as setStorageValue,\n  Z as sleep,\n  G as snakeToCamel\n};\n//# sourceMappingURL=index.js.map\n","export const ERR_AUTH_DATE_INVALID = 'ERR_AUTH_DATE_INVALID';\nexport const ERR_HASH_INVALID = 'ERR_HASH_INVALID';\nexport const ERR_SIGNATURE_MISSING = 'ERR_SIGNATURE_MISSING';\nexport const ERR_EXPIRED = 'ERR_EXPIRED';\nexport const ERR_SIGN_INVALID = 'ERR_SIGN_INVALID';\n","import { TypedError } from '@telegram-apps/toolkit';\n\nimport type { SharedOptions, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\nimport {\n  ERR_AUTH_DATE_INVALID,\n  ERR_EXPIRED,\n  ERR_HASH_INVALID,\n  ERR_SIGN_INVALID,\n} from './errors.js';\n\nexport interface ValidateOptions extends SharedOptions {\n  /**\n   * Time in seconds which states, how long from creation time init data is considered valid.\n   *\n   * In other words, in case when authDate + expiresIn is before current time, init data is\n   * recognized as expired.\n   *\n   * In case this value is equal to 0, the function does not check init data expiration.\n   * @default 86400 (1 day)\n   */\n  expiresIn?: number;\n}\n\nexport type ValidateValue = string | URLSearchParams;\n\nfunction processSign(actual: string, expected: string): void | never {\n  if (actual !== expected) {\n    throw new TypedError(ERR_SIGN_INVALID, 'Sign is invalid');\n  }\n  return;\n}\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_HASH_INVALID\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn,\n  options?: ValidateOptions,\n): void | never;\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_HASH_INVALID\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataAsyncFn,\n  options?: ValidateOptions,\n): Promise<void>;\n\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options: ValidateOptions = {},\n): void | never | Promise<void> {\n  // Init data required params.\n  let authDate: Date | undefined;\n  let hash: string | undefined;\n\n  // All search params pairs presented as `k=v`.\n  const pairs: string[] = [];\n\n  // Iterate over all key-value pairs of parsed parameters and find required\n  // parameters.\n  (typeof value === 'string' ? new URLSearchParams(value) : value).forEach((value, key) => {\n    if (key === 'hash') {\n      hash = value;\n      return;\n    }\n\n    if (key === 'auth_date') {\n      const authDateNum = parseInt(value, 10);\n      if (!Number.isNaN(authDateNum)) {\n        authDate = new Date(authDateNum * 1000);\n      }\n    }\n\n    pairs.push(`${key}=${value}`);\n  });\n\n  // Hash and auth date always required.\n  if (!hash) {\n    throw new TypedError(ERR_HASH_INVALID, 'Hash is invalid');\n  }\n\n  if (!authDate) {\n    throw new TypedError(ERR_AUTH_DATE_INVALID, 'Auth date is invalid');\n  }\n\n  // In case, expiration time passed, we do additional parameters check.\n  const { expiresIn = 86400 } = options;\n  if (expiresIn > 0) {\n    // Check if init data expired.\n    if (+authDate + expiresIn * 1000 < Date.now()) {\n      throw new TypedError(ERR_EXPIRED, 'Init data is expired');\n    }\n  }\n\n  // According to docs, we sort all the pairs in alphabetical order.\n  pairs.sort();\n\n  const sign = signData(pairs.join('\\n'), token, options);\n\n  return typeof sign === 'string'\n    ? processSign(sign, hash)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    : sign.then(v => processSign(v, hash!));\n}\n","import type { Text } from './types.js';\nimport type { ValidateOptions, ValidateValue } from './validate.js';\n\ntype ValidateSyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => void | never;\n\ntype ValidateAsyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => Promise<void>;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn,\n  options?: ValidateOptions,\n): boolean;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateAsyncFn,\n  options?: ValidateOptions,\n): Promise<boolean>;\n\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn | ValidateAsyncFn,\n  options?: ValidateOptions,\n): boolean | Promise<boolean> {\n  try {\n    const maybePromise = validate(value, token, options);\n    return maybePromise\n      ? maybePromise.then(() => true, () => false)\n      : true;\n  } catch {\n    return false;\n  }\n}\n","import { TypedError } from '@telegram-apps/toolkit';\n\nimport type { Verify3rdFn } from './types.js';\nimport {\n  ERR_AUTH_DATE_INVALID,\n  ERR_EXPIRED,\n  ERR_SIGN_INVALID,\n  ERR_SIGNATURE_MISSING,\n} from './errors.js';\n\nexport interface Validate3rdOptions {\n  /**\n   * Time in seconds which states, how long from creation time init data is considered valid.\n   *\n   * In other words, in case when authDate + expiresIn is before current time, init data is\n   * recognized as expired.\n   *\n   * In case this value is equal to 0, the function does not check init data expiration.\n   * @default 86400 (1 day)\n   */\n  expiresIn?: number;\n  /**\n   * When true, uses the test environment public key to validate init data.\n   * @default false\n   */\n  test?: boolean;\n}\n\nexport type Validate3rdValue = string | URLSearchParams;\n\nfunction processResult(verified: boolean): void | never {\n  if (!verified) {\n    throw new TypedError(ERR_SIGN_INVALID, 'Sign is invalid');\n  }\n  return;\n}\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param verify - function to verify sign\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_SIGNATURE_MISSING\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<false>,\n  options?: Validate3rdOptions,\n): void | never;\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param verify - function to verify sign\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_SIGNATURE_MISSING\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<true>,\n  options?: Validate3rdOptions,\n): Promise<void>;\n\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<boolean>,\n  options: Validate3rdOptions = {},\n): void | never | Promise<void> {\n  // Init data required params.\n  let authDate: Date | undefined;\n  let signature: string | undefined;\n\n  // All search params pairs presented as `k=v`.\n  const pairs: string[] = [];\n\n  // Iterate over all key-value pairs of parsed parameters and find required\n  // parameters.\n  (typeof value === 'string' ? new URLSearchParams(value) : value).forEach((value, key) => {\n    if (key === 'hash') {\n      return;\n    }\n\n    if (key === 'signature') {\n      signature = value;\n      return;\n    }\n\n    if (key === 'auth_date') {\n      const authDateNum = parseInt(value, 10);\n      if (!Number.isNaN(authDateNum)) {\n        authDate = new Date(authDateNum * 1000);\n      }\n    }\n\n    pairs.push(`${key}=${value}`);\n  });\n\n  // Signature and auth date always required.\n  if (!signature) {\n    throw new TypedError(ERR_SIGNATURE_MISSING, 'Signature is missing');\n  }\n\n  if (!authDate) {\n    throw new TypedError(ERR_AUTH_DATE_INVALID, 'Auth date is invalid');\n  }\n\n  // In case, expiration time passed, we do additional parameters check.\n  const { expiresIn = 86400 } = options;\n  if (expiresIn > 0) {\n    // Check if init data expired.\n    if (+authDate + expiresIn * 1000 < Date.now()) {\n      throw new TypedError(ERR_EXPIRED, 'Init data is expired');\n    }\n  }\n\n  const verified = verify(\n    `${botId}:WebAppData\\n${pairs.sort().join('\\n')}`,\n    options.test\n      ? '40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec'\n      : 'e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d',\n    signature,\n  );\n\n  return typeof verified === 'boolean' ? processResult(verified) : verified.then(processResult);\n}\n","import type { Validate3rdOptions, Validate3rdValue } from './validate3rd.js';\n\ntype ValidateSyncFn = (\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n) => void | never;\n\ntype ValidateAsyncFn = (\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n) => Promise<void>;\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateAsyncFn,\n  options?: Validate3rdOptions,\n): Promise<boolean>;\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateSyncFn,\n  options?: Validate3rdOptions,\n): boolean;\n\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateSyncFn | ValidateAsyncFn,\n  options?: Validate3rdOptions,\n): boolean | Promise<boolean> {\n  try {\n    const maybePromise = validate(value, botId, options);\n    return maybePromise\n      ? maybePromise.then(() => true, () => false)\n      : true;\n  } catch {\n    return false;\n  }\n}\n","class u extends Error {\n  constructor(e, r, n) {\n    super(\n      typeof r == \"object\" ? r.message : r || e,\n      {\n        cause: typeof r == \"object\" ? r.cause : n\n      }\n    ), this.type = e, this.name = \"TypedError\", Object.setPrototypeOf(this, u.prototype);\n  }\n}\nfunction h(t) {\n  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction S(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nconst w = \"ERR_INVALID_VALUE\", D = \"ERR_UNEXPECTED_VALUE\", W = \"ERR_UNEXPECTED_TYPE\", d = \"ERR_PARSE\";\nfunction A(t, e) {\n  const r = {};\n  for (const n in t) {\n    const o = t[n];\n    if (!o)\n      continue;\n    let a, c;\n    typeof o == \"function\" ? (a = n, c = o) : [a, c] = o;\n    try {\n      const s = c(e(a));\n      s !== void 0 && (r[n] = s);\n    } catch (s) {\n      throw new u(\n        d,\n        `Parser for \"${n}\" property failed${a === n ? \"\" : `. Source field: \"${a}\"`}`,\n        s\n      );\n    }\n  }\n  return r;\n}\nfunction P(t) {\n  let e = t;\n  if (typeof e == \"string\")\n    try {\n      e = JSON.parse(e);\n    } catch (r) {\n      throw new u(w, { cause: r });\n    }\n  if (typeof e != \"object\" || !e || Array.isArray(e))\n    throw new u(D);\n  return e;\n}\nfunction i(t, e) {\n  return (r) => {\n    const n = (o) => {\n      if (!(r && o === void 0))\n        try {\n          return e(o);\n        } catch (a) {\n          throw new u(d, {\n            message: `\"${t}\" transformer failed to parse the value`,\n            cause: a\n          });\n        }\n    };\n    return /* @__PURE__ */ Object.assign(\n      n,\n      {\n        isValid(o) {\n          try {\n            return n(o), !0;\n          } catch {\n            return !1;\n          }\n        }\n      }\n    );\n  };\n}\nfunction m(t, e) {\n  return i(e || \"object\", (r) => {\n    const n = P(r);\n    return A(t, (o) => n[o]);\n  });\n}\nfunction p(t) {\n  throw new u(W, `Unexpected value received: ${JSON.stringify(t)}`);\n}\nconst E = i(\"boolean\", (t) => {\n  if (typeof t == \"boolean\")\n    return t;\n  const e = String(t);\n  if (e === \"1\" || e === \"true\")\n    return !0;\n  if (e === \"0\" || e === \"false\")\n    return !1;\n  p(t);\n}), f = i(\"string\", (t) => {\n  if (typeof t == \"string\" || typeof t == \"number\")\n    return t.toString();\n  p(t);\n}), g = i(\"number\", (t) => {\n  if (typeof t == \"number\")\n    return t;\n  if (typeof t == \"string\") {\n    const e = Number(t);\n    if (!Number.isNaN(e))\n      return e;\n  }\n  p(t);\n}), U = i(\"date\", (t) => t instanceof Date ? t : new Date(g()(t) * 1e3));\nfunction R(t, e) {\n  return i(e || \"searchParams\", (r) => {\n    typeof r != \"string\" && !(r instanceof URLSearchParams) && p(r);\n    const n = typeof r == \"string\" ? new URLSearchParams(r) : r;\n    return A(t, (o) => {\n      const a = n.get(o);\n      return a === null ? void 0 : a;\n    });\n  });\n}\nfunction l(t) {\n  for (const e in t)\n    t[e] = [h(e), t[e]];\n  return t;\n}\nconst N = (t) => {\n  const e = g(), r = g(!0), n = f(), o = f(!0), a = E(!0), c = m(l({\n    addedToAttachmentMenu: a,\n    allowsWriteToPm: a,\n    firstName: n,\n    id: e,\n    isBot: a,\n    isPremium: a,\n    languageCode: o,\n    lastName: o,\n    photoUrl: o,\n    username: o\n  }), \"User\")(!0);\n  return R(\n    l({\n      authDate: U(),\n      canSendAfter: r,\n      chat: m(\n        l({\n          id: e,\n          type: n,\n          title: n,\n          photoUrl: o,\n          username: o\n        }),\n        \"Chat\"\n      )(!0),\n      chatInstance: o,\n      chatType: o,\n      hash: n,\n      queryId: o,\n      receiver: c,\n      startParam: o,\n      signature: n,\n      user: c\n    }),\n    \"initData\"\n  )(t);\n};\nfunction O(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nfunction T(t) {\n  return /^#[\\da-f]{3}$/i.test(t);\n}\nfunction _(t) {\n  const e = t.replace(/\\s/g, \"\").toLowerCase();\n  if (O(e))\n    return e;\n  if (T(e)) {\n    let n = \"#\";\n    for (let o = 0; o < 3; o += 1)\n      n += e[1 + o].repeat(2);\n    return n;\n  }\n  const r = e.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || e.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${t}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((n, o) => {\n    const a = parseInt(o, 10).toString(16);\n    return n + (a.length === 1 ? \"0\" : \"\") + a;\n  }, \"#\");\n}\nconst C = i(\"rgb\", (t) => _(f()(t))), b = i(\n  \"themeParams\",\n  (t) => {\n    const e = C(!0);\n    return Object.entries(P(t)).reduce((r, [n, o]) => (r[S(n)] = e(o), r), {});\n  }\n);\n// @__NO_SIDE_EFFECTS__\nfunction y(t) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(t).map(([e, r]) => [h(e), r])\n    )\n  );\n}\nconst V = (t) => {\n  const e = f(), r = f(!0), n = E(!0);\n  return R({\n    botInline: [\"tgWebAppBotInline\", n],\n    defaultColors: [\"tgWebAppDefaultColors\", b(!0)],\n    fullscreen: [\"tgWebAppFullscreen\", n],\n    initData: [\"tgWebAppData\", N(!0)],\n    initDataRaw: [\"tgWebAppData\", r],\n    platform: [\"tgWebAppPlatform\", e],\n    showSettings: [\"tgWebAppShowSettings\", n],\n    startParam: [\"tgWebAppStartParam\", r],\n    themeParams: [\"tgWebAppThemeParams\", b()],\n    version: [\"tgWebAppVersion\", e]\n  }, \"launchParams\")(t);\n};\n// @__NO_SIDE_EFFECTS__\nfunction $(t) {\n  const {\n    initDataRaw: e,\n    startParam: r,\n    showSettings: n,\n    botInline: o,\n    fullscreen: a,\n    defaultColors: c\n  } = t, s = new URLSearchParams();\n  return s.set(\"tgWebAppPlatform\", t.platform), s.set(\"tgWebAppThemeParams\", /* @__PURE__ */ y(t.themeParams)), s.set(\"tgWebAppVersion\", t.version), e && s.set(\"tgWebAppData\", e), r && s.set(\"tgWebAppStartParam\", r), typeof n == \"boolean\" && s.set(\"tgWebAppShowSettings\", n ? \"1\" : \"0\"), typeof o == \"boolean\" && s.set(\"tgWebAppBotInline\", o ? \"1\" : \"0\"), typeof a == \"boolean\" && s.set(\"tgWebAppFullscreen\", a ? \"1\" : \"0\"), c && s.set(\"tgWebAppDefaultColors\", /* @__PURE__ */ y(c)), s.toString();\n}\nconst j = m({\n  eventType: f(),\n  eventData: (t) => t\n}, \"miniAppsMessage\");\nfunction L(t, e) {\n  return i(e || \"array\", (r) => {\n    let n;\n    if (Array.isArray(r))\n      n = r;\n    else if (typeof r == \"string\")\n      try {\n        const o = JSON.parse(r);\n        Array.isArray(o) && (n = o);\n      } catch {\n      }\n    return n || p(r), n.map(t);\n  });\n}\nconst I = i(\"fn\", (t) => {\n  if (typeof t == \"function\")\n    return t;\n  p(t);\n});\nfunction B(t) {\n  return !!t && typeof t == \"object\" && !Array.isArray(t);\n}\nexport {\n  w as ERR_INVALID_VALUE,\n  d as ERR_PARSE,\n  W as ERR_UNEXPECTED_TYPE,\n  D as ERR_UNEXPECTED_VALUE,\n  L as array,\n  E as boolean,\n  i as createTransformerGen,\n  U as date,\n  I as fn,\n  N as initData,\n  O as isRGB,\n  T as isRGBShort,\n  B as isRecord,\n  V as launchParams,\n  j as miniAppsMessage,\n  g as number,\n  m as object,\n  C as rgb,\n  R as searchParams,\n  $ as serializeLaunchParams,\n  y as serializeThemeParams,\n  f as string,\n  b as themeParams,\n  _ as toRGB,\n  P as toRecord\n};\n//# sourceMappingURL=index.js.map\n","import { initData } from '@telegram-apps/transformers';\nimport type { InitData } from '@telegram-apps/types';\n\n/**\n * Parses incoming value as init data.\n * @param value - value to check.\n * @throws {TypedError} ERR_PARSE\n * @throws {TypedError} ERR_UNEXPECTED_VALUE\n */\nexport function parse(value: unknown): InitData {\n  return initData()(value);\n}","import {\n  validate3rd as _validate3rd,\n  type Validate3rdValue,\n  type Validate3rdOptions,\n} from '../validate3rd.js';\nimport { isValid3rd as _isValid3rd } from '../isValid3rd.js';\nimport type { Verify3rdFn } from '../types.js';\n\nexport type { Chat, ChatType, InitData, User } from '@telegram-apps/types';\nexport { TypedError, isErrorOfType } from '@telegram-apps/toolkit';\nexport { ERR_PARSE, ERR_UNEXPECTED_VALUE } from '@telegram-apps/transformers';\n\nexport { initDataToSearchParams } from '../initDataToSearchParams.js';\nexport { parse } from '../parse.js';\nexport type { ValidateOptions, ValidateValue } from '../validate.js';\nexport type { SignData, Text, CreateHmacFn } from '../types.js';\nexport {\n  ERR_HASH_INVALID,\n  ERR_AUTH_DATE_INVALID,\n  ERR_EXPIRED,\n  ERR_SIGN_INVALID,\n} from '../errors.js';\n\nexport type { Validate3rdValue, Validate3rdOptions, Verify3rdFn };\n\nconst verify3rd: Verify3rdFn<true> = async (data, key, signature) => {\n  return crypto.subtle.verify(\n    'Ed25519',\n    await crypto\n      .subtle\n      .importKey('raw', Buffer.from(key, 'hex'), 'Ed25519', false, ['verify']),\n    Buffer.from(signature, 'base64'),\n    Buffer.from(data),\n  );\n};\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_SIGNATURE_MISSING\n * @throws {Error} ERR_EXPIRED\n */\nexport async function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n): Promise<void> {\n  return _validate3rd(value, botId, verify3rd, options);\n}\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n): Promise<boolean> {\n  return _isValid3rd(value, botId, validate3rd, options);\n}"],"names":["signData","processSign","sign","i","d","TypedError","value","validate","validate3rd","isValid3rd","initData","_validate3rd","_isValid3rd"],"mappings":"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"}